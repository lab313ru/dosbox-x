/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef DosboxDebugger_H
#define DosboxDebugger_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "debug_proto_types.h"



#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class DosboxDebuggerIf {
 public:
  virtual ~DosboxDebuggerIf() {}
  virtual int32_t get_cpu_reg(const CpuRegister::type reg) = 0;
  virtual void get_cpu_regs(CpuRegisters& _return) = 0;
  virtual void set_cpu_reg(const CpuRegister::type reg, const int32_t value) = 0;
  virtual int16_t get_seg_reg(const SegRegister::type reg) = 0;
  virtual void get_seg_regs(SegRegisters& _return) = 0;
  virtual void set_seg_reg(const SegRegister::type reg, const int16_t value) = 0;
  virtual int32_t get_seg_base(const int16_t seg_val) = 0;
  virtual void get_seg_bases(SegBases& _return) = 0;
  virtual double get_fpu_reg(const FpuRegister::type reg) = 0;
  virtual void get_fpu_regs(FpuRegisters& _return) = 0;
  virtual void set_fpu_reg(const FpuRegister::type reg, const double value) = 0;
  virtual void read_memory(std::string& _return, const int32_t phys_addr, const int32_t size) = 0;
  virtual void write_memory(const int32_t phys_addr, const std::string& data) = 0;
  virtual void add_breakpoint(const DbgBreakpoint& bpt) = 0;
  virtual void del_breakpoint(const DbgBreakpoint& bpt) = 0;
  virtual void pause() = 0;
  virtual void resume() = 0;
  virtual void start_emulation() = 0;
  virtual void exit_emulation() = 0;
  virtual void step_into() = 0;
  virtual void step_over() = 0;
};

class DosboxDebuggerIfFactory {
 public:
  typedef DosboxDebuggerIf Handler;

  virtual ~DosboxDebuggerIfFactory() {}

  virtual DosboxDebuggerIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(DosboxDebuggerIf* /* handler */) = 0;
};

class DosboxDebuggerIfSingletonFactory : virtual public DosboxDebuggerIfFactory {
 public:
  DosboxDebuggerIfSingletonFactory(const ::std::shared_ptr<DosboxDebuggerIf>& iface) : iface_(iface) {}
  virtual ~DosboxDebuggerIfSingletonFactory() {}

  virtual DosboxDebuggerIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(DosboxDebuggerIf* /* handler */) {}

 protected:
  ::std::shared_ptr<DosboxDebuggerIf> iface_;
};

class DosboxDebuggerNull : virtual public DosboxDebuggerIf {
 public:
  virtual ~DosboxDebuggerNull() {}
  int32_t get_cpu_reg(const CpuRegister::type /* reg */) {
    int32_t _return = 0;
    return _return;
  }
  void get_cpu_regs(CpuRegisters& /* _return */) {
    return;
  }
  void set_cpu_reg(const CpuRegister::type /* reg */, const int32_t /* value */) {
    return;
  }
  int16_t get_seg_reg(const SegRegister::type /* reg */) {
    int16_t _return = 0;
    return _return;
  }
  void get_seg_regs(SegRegisters& /* _return */) {
    return;
  }
  void set_seg_reg(const SegRegister::type /* reg */, const int16_t /* value */) {
    return;
  }
  int32_t get_seg_base(const int16_t /* seg_val */) {
    int32_t _return = 0;
    return _return;
  }
  void get_seg_bases(SegBases& /* _return */) {
    return;
  }
  double get_fpu_reg(const FpuRegister::type /* reg */) {
    double _return = (double)0;
    return _return;
  }
  void get_fpu_regs(FpuRegisters& /* _return */) {
    return;
  }
  void set_fpu_reg(const FpuRegister::type /* reg */, const double /* value */) {
    return;
  }
  void read_memory(std::string& /* _return */, const int32_t /* phys_addr */, const int32_t /* size */) {
    return;
  }
  void write_memory(const int32_t /* phys_addr */, const std::string& /* data */) {
    return;
  }
  void add_breakpoint(const DbgBreakpoint& /* bpt */) {
    return;
  }
  void del_breakpoint(const DbgBreakpoint& /* bpt */) {
    return;
  }
  void pause() {
    return;
  }
  void resume() {
    return;
  }
  void start_emulation() {
    return;
  }
  void exit_emulation() {
    return;
  }
  void step_into() {
    return;
  }
  void step_over() {
    return;
  }
};

typedef struct _DosboxDebugger_get_cpu_reg_args__isset {
  _DosboxDebugger_get_cpu_reg_args__isset() : reg(false) {}
  bool reg :1;
} _DosboxDebugger_get_cpu_reg_args__isset;

class DosboxDebugger_get_cpu_reg_args {
 public:

  DosboxDebugger_get_cpu_reg_args(const DosboxDebugger_get_cpu_reg_args&);
  DosboxDebugger_get_cpu_reg_args& operator=(const DosboxDebugger_get_cpu_reg_args&);
  DosboxDebugger_get_cpu_reg_args() : reg((CpuRegister::type)0) {
  }

  virtual ~DosboxDebugger_get_cpu_reg_args() noexcept;
  /**
   * 
   * @see CpuRegister
   */
  CpuRegister::type reg;

  _DosboxDebugger_get_cpu_reg_args__isset __isset;

  void __set_reg(const CpuRegister::type val);

  bool operator == (const DosboxDebugger_get_cpu_reg_args & rhs) const
  {
    if (!(reg == rhs.reg))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_get_cpu_reg_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_cpu_reg_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_get_cpu_reg_pargs {
 public:


  virtual ~DosboxDebugger_get_cpu_reg_pargs() noexcept;
  /**
   * 
   * @see CpuRegister
   */
  const CpuRegister::type* reg;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_cpu_reg_result__isset {
  _DosboxDebugger_get_cpu_reg_result__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_cpu_reg_result__isset;

class DosboxDebugger_get_cpu_reg_result {
 public:

  DosboxDebugger_get_cpu_reg_result(const DosboxDebugger_get_cpu_reg_result&);
  DosboxDebugger_get_cpu_reg_result& operator=(const DosboxDebugger_get_cpu_reg_result&);
  DosboxDebugger_get_cpu_reg_result() : success(0) {
  }

  virtual ~DosboxDebugger_get_cpu_reg_result() noexcept;
  int32_t success;

  _DosboxDebugger_get_cpu_reg_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const DosboxDebugger_get_cpu_reg_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_get_cpu_reg_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_cpu_reg_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_cpu_reg_presult__isset {
  _DosboxDebugger_get_cpu_reg_presult__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_cpu_reg_presult__isset;

class DosboxDebugger_get_cpu_reg_presult {
 public:


  virtual ~DosboxDebugger_get_cpu_reg_presult() noexcept;
  int32_t* success;

  _DosboxDebugger_get_cpu_reg_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class DosboxDebugger_get_cpu_regs_args {
 public:

  DosboxDebugger_get_cpu_regs_args(const DosboxDebugger_get_cpu_regs_args&);
  DosboxDebugger_get_cpu_regs_args& operator=(const DosboxDebugger_get_cpu_regs_args&);
  DosboxDebugger_get_cpu_regs_args() {
  }

  virtual ~DosboxDebugger_get_cpu_regs_args() noexcept;

  bool operator == (const DosboxDebugger_get_cpu_regs_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_get_cpu_regs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_cpu_regs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_get_cpu_regs_pargs {
 public:


  virtual ~DosboxDebugger_get_cpu_regs_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_cpu_regs_result__isset {
  _DosboxDebugger_get_cpu_regs_result__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_cpu_regs_result__isset;

class DosboxDebugger_get_cpu_regs_result {
 public:

  DosboxDebugger_get_cpu_regs_result(const DosboxDebugger_get_cpu_regs_result&);
  DosboxDebugger_get_cpu_regs_result& operator=(const DosboxDebugger_get_cpu_regs_result&);
  DosboxDebugger_get_cpu_regs_result() {
  }

  virtual ~DosboxDebugger_get_cpu_regs_result() noexcept;
  CpuRegisters success;

  _DosboxDebugger_get_cpu_regs_result__isset __isset;

  void __set_success(const CpuRegisters& val);

  bool operator == (const DosboxDebugger_get_cpu_regs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_get_cpu_regs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_cpu_regs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_cpu_regs_presult__isset {
  _DosboxDebugger_get_cpu_regs_presult__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_cpu_regs_presult__isset;

class DosboxDebugger_get_cpu_regs_presult {
 public:


  virtual ~DosboxDebugger_get_cpu_regs_presult() noexcept;
  CpuRegisters* success;

  _DosboxDebugger_get_cpu_regs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DosboxDebugger_set_cpu_reg_args__isset {
  _DosboxDebugger_set_cpu_reg_args__isset() : reg(false), value(false) {}
  bool reg :1;
  bool value :1;
} _DosboxDebugger_set_cpu_reg_args__isset;

class DosboxDebugger_set_cpu_reg_args {
 public:

  DosboxDebugger_set_cpu_reg_args(const DosboxDebugger_set_cpu_reg_args&);
  DosboxDebugger_set_cpu_reg_args& operator=(const DosboxDebugger_set_cpu_reg_args&);
  DosboxDebugger_set_cpu_reg_args() : reg((CpuRegister::type)0), value(0) {
  }

  virtual ~DosboxDebugger_set_cpu_reg_args() noexcept;
  /**
   * 
   * @see CpuRegister
   */
  CpuRegister::type reg;
  int32_t value;

  _DosboxDebugger_set_cpu_reg_args__isset __isset;

  void __set_reg(const CpuRegister::type val);

  void __set_value(const int32_t val);

  bool operator == (const DosboxDebugger_set_cpu_reg_args & rhs) const
  {
    if (!(reg == rhs.reg))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_set_cpu_reg_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_set_cpu_reg_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_set_cpu_reg_pargs {
 public:


  virtual ~DosboxDebugger_set_cpu_reg_pargs() noexcept;
  /**
   * 
   * @see CpuRegister
   */
  const CpuRegister::type* reg;
  const int32_t* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_set_cpu_reg_result {
 public:

  DosboxDebugger_set_cpu_reg_result(const DosboxDebugger_set_cpu_reg_result&);
  DosboxDebugger_set_cpu_reg_result& operator=(const DosboxDebugger_set_cpu_reg_result&);
  DosboxDebugger_set_cpu_reg_result() {
  }

  virtual ~DosboxDebugger_set_cpu_reg_result() noexcept;

  bool operator == (const DosboxDebugger_set_cpu_reg_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_set_cpu_reg_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_set_cpu_reg_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_set_cpu_reg_presult {
 public:


  virtual ~DosboxDebugger_set_cpu_reg_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DosboxDebugger_get_seg_reg_args__isset {
  _DosboxDebugger_get_seg_reg_args__isset() : reg(false) {}
  bool reg :1;
} _DosboxDebugger_get_seg_reg_args__isset;

class DosboxDebugger_get_seg_reg_args {
 public:

  DosboxDebugger_get_seg_reg_args(const DosboxDebugger_get_seg_reg_args&);
  DosboxDebugger_get_seg_reg_args& operator=(const DosboxDebugger_get_seg_reg_args&);
  DosboxDebugger_get_seg_reg_args() : reg((SegRegister::type)0) {
  }

  virtual ~DosboxDebugger_get_seg_reg_args() noexcept;
  /**
   * 
   * @see SegRegister
   */
  SegRegister::type reg;

  _DosboxDebugger_get_seg_reg_args__isset __isset;

  void __set_reg(const SegRegister::type val);

  bool operator == (const DosboxDebugger_get_seg_reg_args & rhs) const
  {
    if (!(reg == rhs.reg))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_get_seg_reg_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_seg_reg_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_get_seg_reg_pargs {
 public:


  virtual ~DosboxDebugger_get_seg_reg_pargs() noexcept;
  /**
   * 
   * @see SegRegister
   */
  const SegRegister::type* reg;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_seg_reg_result__isset {
  _DosboxDebugger_get_seg_reg_result__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_seg_reg_result__isset;

class DosboxDebugger_get_seg_reg_result {
 public:

  DosboxDebugger_get_seg_reg_result(const DosboxDebugger_get_seg_reg_result&);
  DosboxDebugger_get_seg_reg_result& operator=(const DosboxDebugger_get_seg_reg_result&);
  DosboxDebugger_get_seg_reg_result() : success(0) {
  }

  virtual ~DosboxDebugger_get_seg_reg_result() noexcept;
  int16_t success;

  _DosboxDebugger_get_seg_reg_result__isset __isset;

  void __set_success(const int16_t val);

  bool operator == (const DosboxDebugger_get_seg_reg_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_get_seg_reg_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_seg_reg_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_seg_reg_presult__isset {
  _DosboxDebugger_get_seg_reg_presult__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_seg_reg_presult__isset;

class DosboxDebugger_get_seg_reg_presult {
 public:


  virtual ~DosboxDebugger_get_seg_reg_presult() noexcept;
  int16_t* success;

  _DosboxDebugger_get_seg_reg_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class DosboxDebugger_get_seg_regs_args {
 public:

  DosboxDebugger_get_seg_regs_args(const DosboxDebugger_get_seg_regs_args&);
  DosboxDebugger_get_seg_regs_args& operator=(const DosboxDebugger_get_seg_regs_args&);
  DosboxDebugger_get_seg_regs_args() {
  }

  virtual ~DosboxDebugger_get_seg_regs_args() noexcept;

  bool operator == (const DosboxDebugger_get_seg_regs_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_get_seg_regs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_seg_regs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_get_seg_regs_pargs {
 public:


  virtual ~DosboxDebugger_get_seg_regs_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_seg_regs_result__isset {
  _DosboxDebugger_get_seg_regs_result__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_seg_regs_result__isset;

class DosboxDebugger_get_seg_regs_result {
 public:

  DosboxDebugger_get_seg_regs_result(const DosboxDebugger_get_seg_regs_result&);
  DosboxDebugger_get_seg_regs_result& operator=(const DosboxDebugger_get_seg_regs_result&);
  DosboxDebugger_get_seg_regs_result() {
  }

  virtual ~DosboxDebugger_get_seg_regs_result() noexcept;
  SegRegisters success;

  _DosboxDebugger_get_seg_regs_result__isset __isset;

  void __set_success(const SegRegisters& val);

  bool operator == (const DosboxDebugger_get_seg_regs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_get_seg_regs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_seg_regs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_seg_regs_presult__isset {
  _DosboxDebugger_get_seg_regs_presult__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_seg_regs_presult__isset;

class DosboxDebugger_get_seg_regs_presult {
 public:


  virtual ~DosboxDebugger_get_seg_regs_presult() noexcept;
  SegRegisters* success;

  _DosboxDebugger_get_seg_regs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DosboxDebugger_set_seg_reg_args__isset {
  _DosboxDebugger_set_seg_reg_args__isset() : reg(false), value(false) {}
  bool reg :1;
  bool value :1;
} _DosboxDebugger_set_seg_reg_args__isset;

class DosboxDebugger_set_seg_reg_args {
 public:

  DosboxDebugger_set_seg_reg_args(const DosboxDebugger_set_seg_reg_args&);
  DosboxDebugger_set_seg_reg_args& operator=(const DosboxDebugger_set_seg_reg_args&);
  DosboxDebugger_set_seg_reg_args() : reg((SegRegister::type)0), value(0) {
  }

  virtual ~DosboxDebugger_set_seg_reg_args() noexcept;
  /**
   * 
   * @see SegRegister
   */
  SegRegister::type reg;
  int16_t value;

  _DosboxDebugger_set_seg_reg_args__isset __isset;

  void __set_reg(const SegRegister::type val);

  void __set_value(const int16_t val);

  bool operator == (const DosboxDebugger_set_seg_reg_args & rhs) const
  {
    if (!(reg == rhs.reg))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_set_seg_reg_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_set_seg_reg_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_set_seg_reg_pargs {
 public:


  virtual ~DosboxDebugger_set_seg_reg_pargs() noexcept;
  /**
   * 
   * @see SegRegister
   */
  const SegRegister::type* reg;
  const int16_t* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_set_seg_reg_result {
 public:

  DosboxDebugger_set_seg_reg_result(const DosboxDebugger_set_seg_reg_result&);
  DosboxDebugger_set_seg_reg_result& operator=(const DosboxDebugger_set_seg_reg_result&);
  DosboxDebugger_set_seg_reg_result() {
  }

  virtual ~DosboxDebugger_set_seg_reg_result() noexcept;

  bool operator == (const DosboxDebugger_set_seg_reg_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_set_seg_reg_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_set_seg_reg_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_set_seg_reg_presult {
 public:


  virtual ~DosboxDebugger_set_seg_reg_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DosboxDebugger_get_seg_base_args__isset {
  _DosboxDebugger_get_seg_base_args__isset() : seg_val(false) {}
  bool seg_val :1;
} _DosboxDebugger_get_seg_base_args__isset;

class DosboxDebugger_get_seg_base_args {
 public:

  DosboxDebugger_get_seg_base_args(const DosboxDebugger_get_seg_base_args&);
  DosboxDebugger_get_seg_base_args& operator=(const DosboxDebugger_get_seg_base_args&);
  DosboxDebugger_get_seg_base_args() : seg_val(0) {
  }

  virtual ~DosboxDebugger_get_seg_base_args() noexcept;
  int16_t seg_val;

  _DosboxDebugger_get_seg_base_args__isset __isset;

  void __set_seg_val(const int16_t val);

  bool operator == (const DosboxDebugger_get_seg_base_args & rhs) const
  {
    if (!(seg_val == rhs.seg_val))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_get_seg_base_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_seg_base_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_get_seg_base_pargs {
 public:


  virtual ~DosboxDebugger_get_seg_base_pargs() noexcept;
  const int16_t* seg_val;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_seg_base_result__isset {
  _DosboxDebugger_get_seg_base_result__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_seg_base_result__isset;

class DosboxDebugger_get_seg_base_result {
 public:

  DosboxDebugger_get_seg_base_result(const DosboxDebugger_get_seg_base_result&);
  DosboxDebugger_get_seg_base_result& operator=(const DosboxDebugger_get_seg_base_result&);
  DosboxDebugger_get_seg_base_result() : success(0) {
  }

  virtual ~DosboxDebugger_get_seg_base_result() noexcept;
  int32_t success;

  _DosboxDebugger_get_seg_base_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const DosboxDebugger_get_seg_base_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_get_seg_base_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_seg_base_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_seg_base_presult__isset {
  _DosboxDebugger_get_seg_base_presult__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_seg_base_presult__isset;

class DosboxDebugger_get_seg_base_presult {
 public:


  virtual ~DosboxDebugger_get_seg_base_presult() noexcept;
  int32_t* success;

  _DosboxDebugger_get_seg_base_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class DosboxDebugger_get_seg_bases_args {
 public:

  DosboxDebugger_get_seg_bases_args(const DosboxDebugger_get_seg_bases_args&);
  DosboxDebugger_get_seg_bases_args& operator=(const DosboxDebugger_get_seg_bases_args&);
  DosboxDebugger_get_seg_bases_args() {
  }

  virtual ~DosboxDebugger_get_seg_bases_args() noexcept;

  bool operator == (const DosboxDebugger_get_seg_bases_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_get_seg_bases_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_seg_bases_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_get_seg_bases_pargs {
 public:


  virtual ~DosboxDebugger_get_seg_bases_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_seg_bases_result__isset {
  _DosboxDebugger_get_seg_bases_result__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_seg_bases_result__isset;

class DosboxDebugger_get_seg_bases_result {
 public:

  DosboxDebugger_get_seg_bases_result(const DosboxDebugger_get_seg_bases_result&);
  DosboxDebugger_get_seg_bases_result& operator=(const DosboxDebugger_get_seg_bases_result&);
  DosboxDebugger_get_seg_bases_result() {
  }

  virtual ~DosboxDebugger_get_seg_bases_result() noexcept;
  SegBases success;

  _DosboxDebugger_get_seg_bases_result__isset __isset;

  void __set_success(const SegBases& val);

  bool operator == (const DosboxDebugger_get_seg_bases_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_get_seg_bases_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_seg_bases_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_seg_bases_presult__isset {
  _DosboxDebugger_get_seg_bases_presult__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_seg_bases_presult__isset;

class DosboxDebugger_get_seg_bases_presult {
 public:


  virtual ~DosboxDebugger_get_seg_bases_presult() noexcept;
  SegBases* success;

  _DosboxDebugger_get_seg_bases_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DosboxDebugger_get_fpu_reg_args__isset {
  _DosboxDebugger_get_fpu_reg_args__isset() : reg(false) {}
  bool reg :1;
} _DosboxDebugger_get_fpu_reg_args__isset;

class DosboxDebugger_get_fpu_reg_args {
 public:

  DosboxDebugger_get_fpu_reg_args(const DosboxDebugger_get_fpu_reg_args&);
  DosboxDebugger_get_fpu_reg_args& operator=(const DosboxDebugger_get_fpu_reg_args&);
  DosboxDebugger_get_fpu_reg_args() : reg((FpuRegister::type)0) {
  }

  virtual ~DosboxDebugger_get_fpu_reg_args() noexcept;
  /**
   * 
   * @see FpuRegister
   */
  FpuRegister::type reg;

  _DosboxDebugger_get_fpu_reg_args__isset __isset;

  void __set_reg(const FpuRegister::type val);

  bool operator == (const DosboxDebugger_get_fpu_reg_args & rhs) const
  {
    if (!(reg == rhs.reg))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_get_fpu_reg_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_fpu_reg_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_get_fpu_reg_pargs {
 public:


  virtual ~DosboxDebugger_get_fpu_reg_pargs() noexcept;
  /**
   * 
   * @see FpuRegister
   */
  const FpuRegister::type* reg;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_fpu_reg_result__isset {
  _DosboxDebugger_get_fpu_reg_result__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_fpu_reg_result__isset;

class DosboxDebugger_get_fpu_reg_result {
 public:

  DosboxDebugger_get_fpu_reg_result(const DosboxDebugger_get_fpu_reg_result&);
  DosboxDebugger_get_fpu_reg_result& operator=(const DosboxDebugger_get_fpu_reg_result&);
  DosboxDebugger_get_fpu_reg_result() : success(0) {
  }

  virtual ~DosboxDebugger_get_fpu_reg_result() noexcept;
  double success;

  _DosboxDebugger_get_fpu_reg_result__isset __isset;

  void __set_success(const double val);

  bool operator == (const DosboxDebugger_get_fpu_reg_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_get_fpu_reg_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_fpu_reg_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_fpu_reg_presult__isset {
  _DosboxDebugger_get_fpu_reg_presult__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_fpu_reg_presult__isset;

class DosboxDebugger_get_fpu_reg_presult {
 public:


  virtual ~DosboxDebugger_get_fpu_reg_presult() noexcept;
  double* success;

  _DosboxDebugger_get_fpu_reg_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class DosboxDebugger_get_fpu_regs_args {
 public:

  DosboxDebugger_get_fpu_regs_args(const DosboxDebugger_get_fpu_regs_args&);
  DosboxDebugger_get_fpu_regs_args& operator=(const DosboxDebugger_get_fpu_regs_args&);
  DosboxDebugger_get_fpu_regs_args() {
  }

  virtual ~DosboxDebugger_get_fpu_regs_args() noexcept;

  bool operator == (const DosboxDebugger_get_fpu_regs_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_get_fpu_regs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_fpu_regs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_get_fpu_regs_pargs {
 public:


  virtual ~DosboxDebugger_get_fpu_regs_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_fpu_regs_result__isset {
  _DosboxDebugger_get_fpu_regs_result__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_fpu_regs_result__isset;

class DosboxDebugger_get_fpu_regs_result {
 public:

  DosboxDebugger_get_fpu_regs_result(const DosboxDebugger_get_fpu_regs_result&);
  DosboxDebugger_get_fpu_regs_result& operator=(const DosboxDebugger_get_fpu_regs_result&);
  DosboxDebugger_get_fpu_regs_result() {
  }

  virtual ~DosboxDebugger_get_fpu_regs_result() noexcept;
  FpuRegisters success;

  _DosboxDebugger_get_fpu_regs_result__isset __isset;

  void __set_success(const FpuRegisters& val);

  bool operator == (const DosboxDebugger_get_fpu_regs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_get_fpu_regs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_get_fpu_regs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_get_fpu_regs_presult__isset {
  _DosboxDebugger_get_fpu_regs_presult__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_get_fpu_regs_presult__isset;

class DosboxDebugger_get_fpu_regs_presult {
 public:


  virtual ~DosboxDebugger_get_fpu_regs_presult() noexcept;
  FpuRegisters* success;

  _DosboxDebugger_get_fpu_regs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DosboxDebugger_set_fpu_reg_args__isset {
  _DosboxDebugger_set_fpu_reg_args__isset() : reg(false), value(false) {}
  bool reg :1;
  bool value :1;
} _DosboxDebugger_set_fpu_reg_args__isset;

class DosboxDebugger_set_fpu_reg_args {
 public:

  DosboxDebugger_set_fpu_reg_args(const DosboxDebugger_set_fpu_reg_args&);
  DosboxDebugger_set_fpu_reg_args& operator=(const DosboxDebugger_set_fpu_reg_args&);
  DosboxDebugger_set_fpu_reg_args() : reg((FpuRegister::type)0), value(0) {
  }

  virtual ~DosboxDebugger_set_fpu_reg_args() noexcept;
  /**
   * 
   * @see FpuRegister
   */
  FpuRegister::type reg;
  double value;

  _DosboxDebugger_set_fpu_reg_args__isset __isset;

  void __set_reg(const FpuRegister::type val);

  void __set_value(const double val);

  bool operator == (const DosboxDebugger_set_fpu_reg_args & rhs) const
  {
    if (!(reg == rhs.reg))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_set_fpu_reg_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_set_fpu_reg_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_set_fpu_reg_pargs {
 public:


  virtual ~DosboxDebugger_set_fpu_reg_pargs() noexcept;
  /**
   * 
   * @see FpuRegister
   */
  const FpuRegister::type* reg;
  const double* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_set_fpu_reg_result {
 public:

  DosboxDebugger_set_fpu_reg_result(const DosboxDebugger_set_fpu_reg_result&);
  DosboxDebugger_set_fpu_reg_result& operator=(const DosboxDebugger_set_fpu_reg_result&);
  DosboxDebugger_set_fpu_reg_result() {
  }

  virtual ~DosboxDebugger_set_fpu_reg_result() noexcept;

  bool operator == (const DosboxDebugger_set_fpu_reg_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_set_fpu_reg_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_set_fpu_reg_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_set_fpu_reg_presult {
 public:


  virtual ~DosboxDebugger_set_fpu_reg_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DosboxDebugger_read_memory_args__isset {
  _DosboxDebugger_read_memory_args__isset() : phys_addr(false), size(false) {}
  bool phys_addr :1;
  bool size :1;
} _DosboxDebugger_read_memory_args__isset;

class DosboxDebugger_read_memory_args {
 public:

  DosboxDebugger_read_memory_args(const DosboxDebugger_read_memory_args&);
  DosboxDebugger_read_memory_args& operator=(const DosboxDebugger_read_memory_args&);
  DosboxDebugger_read_memory_args() : phys_addr(0), size(0) {
  }

  virtual ~DosboxDebugger_read_memory_args() noexcept;
  int32_t phys_addr;
  int32_t size;

  _DosboxDebugger_read_memory_args__isset __isset;

  void __set_phys_addr(const int32_t val);

  void __set_size(const int32_t val);

  bool operator == (const DosboxDebugger_read_memory_args & rhs) const
  {
    if (!(phys_addr == rhs.phys_addr))
      return false;
    if (!(size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_read_memory_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_read_memory_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_read_memory_pargs {
 public:


  virtual ~DosboxDebugger_read_memory_pargs() noexcept;
  const int32_t* phys_addr;
  const int32_t* size;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_read_memory_result__isset {
  _DosboxDebugger_read_memory_result__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_read_memory_result__isset;

class DosboxDebugger_read_memory_result {
 public:

  DosboxDebugger_read_memory_result(const DosboxDebugger_read_memory_result&);
  DosboxDebugger_read_memory_result& operator=(const DosboxDebugger_read_memory_result&);
  DosboxDebugger_read_memory_result() : success() {
  }

  virtual ~DosboxDebugger_read_memory_result() noexcept;
  std::string success;

  _DosboxDebugger_read_memory_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const DosboxDebugger_read_memory_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_read_memory_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_read_memory_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DosboxDebugger_read_memory_presult__isset {
  _DosboxDebugger_read_memory_presult__isset() : success(false) {}
  bool success :1;
} _DosboxDebugger_read_memory_presult__isset;

class DosboxDebugger_read_memory_presult {
 public:


  virtual ~DosboxDebugger_read_memory_presult() noexcept;
  std::string* success;

  _DosboxDebugger_read_memory_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DosboxDebugger_write_memory_args__isset {
  _DosboxDebugger_write_memory_args__isset() : phys_addr(false), data(false) {}
  bool phys_addr :1;
  bool data :1;
} _DosboxDebugger_write_memory_args__isset;

class DosboxDebugger_write_memory_args {
 public:

  DosboxDebugger_write_memory_args(const DosboxDebugger_write_memory_args&);
  DosboxDebugger_write_memory_args& operator=(const DosboxDebugger_write_memory_args&);
  DosboxDebugger_write_memory_args() : phys_addr(0), data() {
  }

  virtual ~DosboxDebugger_write_memory_args() noexcept;
  int32_t phys_addr;
  std::string data;

  _DosboxDebugger_write_memory_args__isset __isset;

  void __set_phys_addr(const int32_t val);

  void __set_data(const std::string& val);

  bool operator == (const DosboxDebugger_write_memory_args & rhs) const
  {
    if (!(phys_addr == rhs.phys_addr))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_write_memory_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_write_memory_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_write_memory_pargs {
 public:


  virtual ~DosboxDebugger_write_memory_pargs() noexcept;
  const int32_t* phys_addr;
  const std::string* data;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_write_memory_result {
 public:

  DosboxDebugger_write_memory_result(const DosboxDebugger_write_memory_result&);
  DosboxDebugger_write_memory_result& operator=(const DosboxDebugger_write_memory_result&);
  DosboxDebugger_write_memory_result() {
  }

  virtual ~DosboxDebugger_write_memory_result() noexcept;

  bool operator == (const DosboxDebugger_write_memory_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_write_memory_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_write_memory_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_write_memory_presult {
 public:


  virtual ~DosboxDebugger_write_memory_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DosboxDebugger_add_breakpoint_args__isset {
  _DosboxDebugger_add_breakpoint_args__isset() : bpt(false) {}
  bool bpt :1;
} _DosboxDebugger_add_breakpoint_args__isset;

class DosboxDebugger_add_breakpoint_args {
 public:

  DosboxDebugger_add_breakpoint_args(const DosboxDebugger_add_breakpoint_args&);
  DosboxDebugger_add_breakpoint_args& operator=(const DosboxDebugger_add_breakpoint_args&);
  DosboxDebugger_add_breakpoint_args() {
  }

  virtual ~DosboxDebugger_add_breakpoint_args() noexcept;
  DbgBreakpoint bpt;

  _DosboxDebugger_add_breakpoint_args__isset __isset;

  void __set_bpt(const DbgBreakpoint& val);

  bool operator == (const DosboxDebugger_add_breakpoint_args & rhs) const
  {
    if (!(bpt == rhs.bpt))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_add_breakpoint_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_add_breakpoint_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_add_breakpoint_pargs {
 public:


  virtual ~DosboxDebugger_add_breakpoint_pargs() noexcept;
  const DbgBreakpoint* bpt;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_add_breakpoint_result {
 public:

  DosboxDebugger_add_breakpoint_result(const DosboxDebugger_add_breakpoint_result&);
  DosboxDebugger_add_breakpoint_result& operator=(const DosboxDebugger_add_breakpoint_result&);
  DosboxDebugger_add_breakpoint_result() {
  }

  virtual ~DosboxDebugger_add_breakpoint_result() noexcept;

  bool operator == (const DosboxDebugger_add_breakpoint_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_add_breakpoint_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_add_breakpoint_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_add_breakpoint_presult {
 public:


  virtual ~DosboxDebugger_add_breakpoint_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DosboxDebugger_del_breakpoint_args__isset {
  _DosboxDebugger_del_breakpoint_args__isset() : bpt(false) {}
  bool bpt :1;
} _DosboxDebugger_del_breakpoint_args__isset;

class DosboxDebugger_del_breakpoint_args {
 public:

  DosboxDebugger_del_breakpoint_args(const DosboxDebugger_del_breakpoint_args&);
  DosboxDebugger_del_breakpoint_args& operator=(const DosboxDebugger_del_breakpoint_args&);
  DosboxDebugger_del_breakpoint_args() {
  }

  virtual ~DosboxDebugger_del_breakpoint_args() noexcept;
  DbgBreakpoint bpt;

  _DosboxDebugger_del_breakpoint_args__isset __isset;

  void __set_bpt(const DbgBreakpoint& val);

  bool operator == (const DosboxDebugger_del_breakpoint_args & rhs) const
  {
    if (!(bpt == rhs.bpt))
      return false;
    return true;
  }
  bool operator != (const DosboxDebugger_del_breakpoint_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_del_breakpoint_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_del_breakpoint_pargs {
 public:


  virtual ~DosboxDebugger_del_breakpoint_pargs() noexcept;
  const DbgBreakpoint* bpt;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_del_breakpoint_result {
 public:

  DosboxDebugger_del_breakpoint_result(const DosboxDebugger_del_breakpoint_result&);
  DosboxDebugger_del_breakpoint_result& operator=(const DosboxDebugger_del_breakpoint_result&);
  DosboxDebugger_del_breakpoint_result() {
  }

  virtual ~DosboxDebugger_del_breakpoint_result() noexcept;

  bool operator == (const DosboxDebugger_del_breakpoint_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_del_breakpoint_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_del_breakpoint_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_del_breakpoint_presult {
 public:


  virtual ~DosboxDebugger_del_breakpoint_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class DosboxDebugger_pause_args {
 public:

  DosboxDebugger_pause_args(const DosboxDebugger_pause_args&);
  DosboxDebugger_pause_args& operator=(const DosboxDebugger_pause_args&);
  DosboxDebugger_pause_args() {
  }

  virtual ~DosboxDebugger_pause_args() noexcept;

  bool operator == (const DosboxDebugger_pause_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_pause_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_pause_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_pause_pargs {
 public:


  virtual ~DosboxDebugger_pause_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_pause_result {
 public:

  DosboxDebugger_pause_result(const DosboxDebugger_pause_result&);
  DosboxDebugger_pause_result& operator=(const DosboxDebugger_pause_result&);
  DosboxDebugger_pause_result() {
  }

  virtual ~DosboxDebugger_pause_result() noexcept;

  bool operator == (const DosboxDebugger_pause_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_pause_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_pause_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_pause_presult {
 public:


  virtual ~DosboxDebugger_pause_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class DosboxDebugger_resume_args {
 public:

  DosboxDebugger_resume_args(const DosboxDebugger_resume_args&);
  DosboxDebugger_resume_args& operator=(const DosboxDebugger_resume_args&);
  DosboxDebugger_resume_args() {
  }

  virtual ~DosboxDebugger_resume_args() noexcept;

  bool operator == (const DosboxDebugger_resume_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_resume_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_resume_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_resume_pargs {
 public:


  virtual ~DosboxDebugger_resume_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_resume_result {
 public:

  DosboxDebugger_resume_result(const DosboxDebugger_resume_result&);
  DosboxDebugger_resume_result& operator=(const DosboxDebugger_resume_result&);
  DosboxDebugger_resume_result() {
  }

  virtual ~DosboxDebugger_resume_result() noexcept;

  bool operator == (const DosboxDebugger_resume_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_resume_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_resume_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_resume_presult {
 public:


  virtual ~DosboxDebugger_resume_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class DosboxDebugger_start_emulation_args {
 public:

  DosboxDebugger_start_emulation_args(const DosboxDebugger_start_emulation_args&);
  DosboxDebugger_start_emulation_args& operator=(const DosboxDebugger_start_emulation_args&);
  DosboxDebugger_start_emulation_args() {
  }

  virtual ~DosboxDebugger_start_emulation_args() noexcept;

  bool operator == (const DosboxDebugger_start_emulation_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_start_emulation_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_start_emulation_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_start_emulation_pargs {
 public:


  virtual ~DosboxDebugger_start_emulation_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_start_emulation_result {
 public:

  DosboxDebugger_start_emulation_result(const DosboxDebugger_start_emulation_result&);
  DosboxDebugger_start_emulation_result& operator=(const DosboxDebugger_start_emulation_result&);
  DosboxDebugger_start_emulation_result() {
  }

  virtual ~DosboxDebugger_start_emulation_result() noexcept;

  bool operator == (const DosboxDebugger_start_emulation_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_start_emulation_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_start_emulation_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_start_emulation_presult {
 public:


  virtual ~DosboxDebugger_start_emulation_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class DosboxDebugger_exit_emulation_args {
 public:

  DosboxDebugger_exit_emulation_args(const DosboxDebugger_exit_emulation_args&);
  DosboxDebugger_exit_emulation_args& operator=(const DosboxDebugger_exit_emulation_args&);
  DosboxDebugger_exit_emulation_args() {
  }

  virtual ~DosboxDebugger_exit_emulation_args() noexcept;

  bool operator == (const DosboxDebugger_exit_emulation_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_exit_emulation_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_exit_emulation_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_exit_emulation_pargs {
 public:


  virtual ~DosboxDebugger_exit_emulation_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_exit_emulation_result {
 public:

  DosboxDebugger_exit_emulation_result(const DosboxDebugger_exit_emulation_result&);
  DosboxDebugger_exit_emulation_result& operator=(const DosboxDebugger_exit_emulation_result&);
  DosboxDebugger_exit_emulation_result() {
  }

  virtual ~DosboxDebugger_exit_emulation_result() noexcept;

  bool operator == (const DosboxDebugger_exit_emulation_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_exit_emulation_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_exit_emulation_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_exit_emulation_presult {
 public:


  virtual ~DosboxDebugger_exit_emulation_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class DosboxDebugger_step_into_args {
 public:

  DosboxDebugger_step_into_args(const DosboxDebugger_step_into_args&);
  DosboxDebugger_step_into_args& operator=(const DosboxDebugger_step_into_args&);
  DosboxDebugger_step_into_args() {
  }

  virtual ~DosboxDebugger_step_into_args() noexcept;

  bool operator == (const DosboxDebugger_step_into_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_step_into_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_step_into_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_step_into_pargs {
 public:


  virtual ~DosboxDebugger_step_into_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_step_into_result {
 public:

  DosboxDebugger_step_into_result(const DosboxDebugger_step_into_result&);
  DosboxDebugger_step_into_result& operator=(const DosboxDebugger_step_into_result&);
  DosboxDebugger_step_into_result() {
  }

  virtual ~DosboxDebugger_step_into_result() noexcept;

  bool operator == (const DosboxDebugger_step_into_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_step_into_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_step_into_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_step_into_presult {
 public:


  virtual ~DosboxDebugger_step_into_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class DosboxDebugger_step_over_args {
 public:

  DosboxDebugger_step_over_args(const DosboxDebugger_step_over_args&);
  DosboxDebugger_step_over_args& operator=(const DosboxDebugger_step_over_args&);
  DosboxDebugger_step_over_args() {
  }

  virtual ~DosboxDebugger_step_over_args() noexcept;

  bool operator == (const DosboxDebugger_step_over_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_step_over_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_step_over_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_step_over_pargs {
 public:


  virtual ~DosboxDebugger_step_over_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_step_over_result {
 public:

  DosboxDebugger_step_over_result(const DosboxDebugger_step_over_result&);
  DosboxDebugger_step_over_result& operator=(const DosboxDebugger_step_over_result&);
  DosboxDebugger_step_over_result() {
  }

  virtual ~DosboxDebugger_step_over_result() noexcept;

  bool operator == (const DosboxDebugger_step_over_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DosboxDebugger_step_over_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DosboxDebugger_step_over_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DosboxDebugger_step_over_presult {
 public:


  virtual ~DosboxDebugger_step_over_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class DosboxDebuggerClient : virtual public DosboxDebuggerIf {
 public:
  DosboxDebuggerClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  DosboxDebuggerClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  int32_t get_cpu_reg(const CpuRegister::type reg);
  void send_get_cpu_reg(const CpuRegister::type reg);
  int32_t recv_get_cpu_reg();
  void get_cpu_regs(CpuRegisters& _return);
  void send_get_cpu_regs();
  void recv_get_cpu_regs(CpuRegisters& _return);
  void set_cpu_reg(const CpuRegister::type reg, const int32_t value);
  void send_set_cpu_reg(const CpuRegister::type reg, const int32_t value);
  void recv_set_cpu_reg();
  int16_t get_seg_reg(const SegRegister::type reg);
  void send_get_seg_reg(const SegRegister::type reg);
  int16_t recv_get_seg_reg();
  void get_seg_regs(SegRegisters& _return);
  void send_get_seg_regs();
  void recv_get_seg_regs(SegRegisters& _return);
  void set_seg_reg(const SegRegister::type reg, const int16_t value);
  void send_set_seg_reg(const SegRegister::type reg, const int16_t value);
  void recv_set_seg_reg();
  int32_t get_seg_base(const int16_t seg_val);
  void send_get_seg_base(const int16_t seg_val);
  int32_t recv_get_seg_base();
  void get_seg_bases(SegBases& _return);
  void send_get_seg_bases();
  void recv_get_seg_bases(SegBases& _return);
  double get_fpu_reg(const FpuRegister::type reg);
  void send_get_fpu_reg(const FpuRegister::type reg);
  double recv_get_fpu_reg();
  void get_fpu_regs(FpuRegisters& _return);
  void send_get_fpu_regs();
  void recv_get_fpu_regs(FpuRegisters& _return);
  void set_fpu_reg(const FpuRegister::type reg, const double value);
  void send_set_fpu_reg(const FpuRegister::type reg, const double value);
  void recv_set_fpu_reg();
  void read_memory(std::string& _return, const int32_t phys_addr, const int32_t size);
  void send_read_memory(const int32_t phys_addr, const int32_t size);
  void recv_read_memory(std::string& _return);
  void write_memory(const int32_t phys_addr, const std::string& data);
  void send_write_memory(const int32_t phys_addr, const std::string& data);
  void recv_write_memory();
  void add_breakpoint(const DbgBreakpoint& bpt);
  void send_add_breakpoint(const DbgBreakpoint& bpt);
  void recv_add_breakpoint();
  void del_breakpoint(const DbgBreakpoint& bpt);
  void send_del_breakpoint(const DbgBreakpoint& bpt);
  void recv_del_breakpoint();
  void pause();
  void send_pause();
  void recv_pause();
  void resume();
  void send_resume();
  void recv_resume();
  void start_emulation();
  void send_start_emulation();
  void recv_start_emulation();
  void exit_emulation();
  void send_exit_emulation();
  void recv_exit_emulation();
  void step_into();
  void send_step_into();
  void recv_step_into();
  void step_over();
  void send_step_over();
  void recv_step_over();
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class DosboxDebuggerProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::std::shared_ptr<DosboxDebuggerIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (DosboxDebuggerProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_get_cpu_reg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_cpu_regs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_cpu_reg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_seg_reg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_seg_regs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_seg_reg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_seg_base(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_seg_bases(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_fpu_reg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_fpu_regs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_fpu_reg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_read_memory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_write_memory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_add_breakpoint(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_del_breakpoint(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pause(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_resume(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_start_emulation(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_exit_emulation(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_step_into(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_step_over(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  DosboxDebuggerProcessor(::std::shared_ptr<DosboxDebuggerIf> iface) :
    iface_(iface) {
    processMap_["get_cpu_reg"] = &DosboxDebuggerProcessor::process_get_cpu_reg;
    processMap_["get_cpu_regs"] = &DosboxDebuggerProcessor::process_get_cpu_regs;
    processMap_["set_cpu_reg"] = &DosboxDebuggerProcessor::process_set_cpu_reg;
    processMap_["get_seg_reg"] = &DosboxDebuggerProcessor::process_get_seg_reg;
    processMap_["get_seg_regs"] = &DosboxDebuggerProcessor::process_get_seg_regs;
    processMap_["set_seg_reg"] = &DosboxDebuggerProcessor::process_set_seg_reg;
    processMap_["get_seg_base"] = &DosboxDebuggerProcessor::process_get_seg_base;
    processMap_["get_seg_bases"] = &DosboxDebuggerProcessor::process_get_seg_bases;
    processMap_["get_fpu_reg"] = &DosboxDebuggerProcessor::process_get_fpu_reg;
    processMap_["get_fpu_regs"] = &DosboxDebuggerProcessor::process_get_fpu_regs;
    processMap_["set_fpu_reg"] = &DosboxDebuggerProcessor::process_set_fpu_reg;
    processMap_["read_memory"] = &DosboxDebuggerProcessor::process_read_memory;
    processMap_["write_memory"] = &DosboxDebuggerProcessor::process_write_memory;
    processMap_["add_breakpoint"] = &DosboxDebuggerProcessor::process_add_breakpoint;
    processMap_["del_breakpoint"] = &DosboxDebuggerProcessor::process_del_breakpoint;
    processMap_["pause"] = &DosboxDebuggerProcessor::process_pause;
    processMap_["resume"] = &DosboxDebuggerProcessor::process_resume;
    processMap_["start_emulation"] = &DosboxDebuggerProcessor::process_start_emulation;
    processMap_["exit_emulation"] = &DosboxDebuggerProcessor::process_exit_emulation;
    processMap_["step_into"] = &DosboxDebuggerProcessor::process_step_into;
    processMap_["step_over"] = &DosboxDebuggerProcessor::process_step_over;
  }

  virtual ~DosboxDebuggerProcessor() {}
};

class DosboxDebuggerProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  DosboxDebuggerProcessorFactory(const ::std::shared_ptr< DosboxDebuggerIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::std::shared_ptr< DosboxDebuggerIfFactory > handlerFactory_;
};

class DosboxDebuggerMultiface : virtual public DosboxDebuggerIf {
 public:
  DosboxDebuggerMultiface(std::vector<std::shared_ptr<DosboxDebuggerIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~DosboxDebuggerMultiface() {}
 protected:
  std::vector<std::shared_ptr<DosboxDebuggerIf> > ifaces_;
  DosboxDebuggerMultiface() {}
  void add(::std::shared_ptr<DosboxDebuggerIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  int32_t get_cpu_reg(const CpuRegister::type reg) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_cpu_reg(reg);
    }
    return ifaces_[i]->get_cpu_reg(reg);
  }

  void get_cpu_regs(CpuRegisters& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_cpu_regs(_return);
    }
    ifaces_[i]->get_cpu_regs(_return);
    return;
  }

  void set_cpu_reg(const CpuRegister::type reg, const int32_t value) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_cpu_reg(reg, value);
    }
    ifaces_[i]->set_cpu_reg(reg, value);
  }

  int16_t get_seg_reg(const SegRegister::type reg) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_seg_reg(reg);
    }
    return ifaces_[i]->get_seg_reg(reg);
  }

  void get_seg_regs(SegRegisters& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_seg_regs(_return);
    }
    ifaces_[i]->get_seg_regs(_return);
    return;
  }

  void set_seg_reg(const SegRegister::type reg, const int16_t value) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_seg_reg(reg, value);
    }
    ifaces_[i]->set_seg_reg(reg, value);
  }

  int32_t get_seg_base(const int16_t seg_val) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_seg_base(seg_val);
    }
    return ifaces_[i]->get_seg_base(seg_val);
  }

  void get_seg_bases(SegBases& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_seg_bases(_return);
    }
    ifaces_[i]->get_seg_bases(_return);
    return;
  }

  double get_fpu_reg(const FpuRegister::type reg) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_fpu_reg(reg);
    }
    return ifaces_[i]->get_fpu_reg(reg);
  }

  void get_fpu_regs(FpuRegisters& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_fpu_regs(_return);
    }
    ifaces_[i]->get_fpu_regs(_return);
    return;
  }

  void set_fpu_reg(const FpuRegister::type reg, const double value) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_fpu_reg(reg, value);
    }
    ifaces_[i]->set_fpu_reg(reg, value);
  }

  void read_memory(std::string& _return, const int32_t phys_addr, const int32_t size) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->read_memory(_return, phys_addr, size);
    }
    ifaces_[i]->read_memory(_return, phys_addr, size);
    return;
  }

  void write_memory(const int32_t phys_addr, const std::string& data) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->write_memory(phys_addr, data);
    }
    ifaces_[i]->write_memory(phys_addr, data);
  }

  void add_breakpoint(const DbgBreakpoint& bpt) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->add_breakpoint(bpt);
    }
    ifaces_[i]->add_breakpoint(bpt);
  }

  void del_breakpoint(const DbgBreakpoint& bpt) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->del_breakpoint(bpt);
    }
    ifaces_[i]->del_breakpoint(bpt);
  }

  void pause() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pause();
    }
    ifaces_[i]->pause();
  }

  void resume() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->resume();
    }
    ifaces_[i]->resume();
  }

  void start_emulation() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->start_emulation();
    }
    ifaces_[i]->start_emulation();
  }

  void exit_emulation() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->exit_emulation();
    }
    ifaces_[i]->exit_emulation();
  }

  void step_into() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->step_into();
    }
    ifaces_[i]->step_into();
  }

  void step_over() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->step_over();
    }
    ifaces_[i]->step_over();
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class DosboxDebuggerConcurrentClient : virtual public DosboxDebuggerIf {
 public:
  DosboxDebuggerConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(prot);
  }
  DosboxDebuggerConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  int32_t get_cpu_reg(const CpuRegister::type reg);
  int32_t send_get_cpu_reg(const CpuRegister::type reg);
  int32_t recv_get_cpu_reg(const int32_t seqid);
  void get_cpu_regs(CpuRegisters& _return);
  int32_t send_get_cpu_regs();
  void recv_get_cpu_regs(CpuRegisters& _return, const int32_t seqid);
  void set_cpu_reg(const CpuRegister::type reg, const int32_t value);
  int32_t send_set_cpu_reg(const CpuRegister::type reg, const int32_t value);
  void recv_set_cpu_reg(const int32_t seqid);
  int16_t get_seg_reg(const SegRegister::type reg);
  int32_t send_get_seg_reg(const SegRegister::type reg);
  int16_t recv_get_seg_reg(const int32_t seqid);
  void get_seg_regs(SegRegisters& _return);
  int32_t send_get_seg_regs();
  void recv_get_seg_regs(SegRegisters& _return, const int32_t seqid);
  void set_seg_reg(const SegRegister::type reg, const int16_t value);
  int32_t send_set_seg_reg(const SegRegister::type reg, const int16_t value);
  void recv_set_seg_reg(const int32_t seqid);
  int32_t get_seg_base(const int16_t seg_val);
  int32_t send_get_seg_base(const int16_t seg_val);
  int32_t recv_get_seg_base(const int32_t seqid);
  void get_seg_bases(SegBases& _return);
  int32_t send_get_seg_bases();
  void recv_get_seg_bases(SegBases& _return, const int32_t seqid);
  double get_fpu_reg(const FpuRegister::type reg);
  int32_t send_get_fpu_reg(const FpuRegister::type reg);
  double recv_get_fpu_reg(const int32_t seqid);
  void get_fpu_regs(FpuRegisters& _return);
  int32_t send_get_fpu_regs();
  void recv_get_fpu_regs(FpuRegisters& _return, const int32_t seqid);
  void set_fpu_reg(const FpuRegister::type reg, const double value);
  int32_t send_set_fpu_reg(const FpuRegister::type reg, const double value);
  void recv_set_fpu_reg(const int32_t seqid);
  void read_memory(std::string& _return, const int32_t phys_addr, const int32_t size);
  int32_t send_read_memory(const int32_t phys_addr, const int32_t size);
  void recv_read_memory(std::string& _return, const int32_t seqid);
  void write_memory(const int32_t phys_addr, const std::string& data);
  int32_t send_write_memory(const int32_t phys_addr, const std::string& data);
  void recv_write_memory(const int32_t seqid);
  void add_breakpoint(const DbgBreakpoint& bpt);
  int32_t send_add_breakpoint(const DbgBreakpoint& bpt);
  void recv_add_breakpoint(const int32_t seqid);
  void del_breakpoint(const DbgBreakpoint& bpt);
  int32_t send_del_breakpoint(const DbgBreakpoint& bpt);
  void recv_del_breakpoint(const int32_t seqid);
  void pause();
  int32_t send_pause();
  void recv_pause(const int32_t seqid);
  void resume();
  int32_t send_resume();
  void recv_resume(const int32_t seqid);
  void start_emulation();
  int32_t send_start_emulation();
  void recv_start_emulation(const int32_t seqid);
  void exit_emulation();
  int32_t send_exit_emulation();
  void recv_exit_emulation(const int32_t seqid);
  void step_into();
  int32_t send_step_into();
  void recv_step_into(const int32_t seqid);
  void step_over();
  int32_t send_step_over();
  void recv_step_over(const int32_t seqid);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif



#endif
