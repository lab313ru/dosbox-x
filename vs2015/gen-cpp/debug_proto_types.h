/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef debug_proto_TYPES_H
#define debug_proto_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>




struct CpuRegister {
  enum type {
    EAX = 0,
    EBX = 1,
    ECX = 2,
    EDX = 3,
    ESI = 4,
    EDI = 5,
    EBP = 6,
    ESP = 7,
    EIP = 8,
    FLAGS = 9
  };
};

extern const std::map<int, const char*> _CpuRegister_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const CpuRegister::type& val);

std::string to_string(const CpuRegister::type& val);

struct SegRegister {
  enum type {
    CS = 0,
    DS = 1,
    ES = 2,
    FS = 3,
    GS = 4,
    SS = 5
  };
};

extern const std::map<int, const char*> _SegRegister_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SegRegister::type& val);

std::string to_string(const SegRegister::type& val);

struct FpuRegister {
  enum type {
    ST0 = 0,
    ST1 = 1,
    ST2 = 2,
    ST3 = 3,
    ST4 = 4,
    ST5 = 5,
    ST6 = 6,
    ST7 = 7
  };
};

extern const std::map<int, const char*> _FpuRegister_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const FpuRegister::type& val);

std::string to_string(const FpuRegister::type& val);

struct BpType {
  enum type {
    BP_PC = 1,
    BP_READ = 2,
    BP_WRITE = 4
  };
};

extern const std::map<int, const char*> _BpType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const BpType::type& val);

std::string to_string(const BpType::type& val);

class CpuRegisters;

class SegRegisters;

class SegBases;

class FpuRegisters;

class DbgBreakpoint;

typedef struct _CpuRegisters__isset {
  _CpuRegisters__isset() : EAX(false), EBX(false), ECX(false), EDX(false), ESI(false), EDI(false), EBP(false), ESP(false), EIP(false), FLAGS(false) {}
  bool EAX :1;
  bool EBX :1;
  bool ECX :1;
  bool EDX :1;
  bool ESI :1;
  bool EDI :1;
  bool EBP :1;
  bool ESP :1;
  bool EIP :1;
  bool FLAGS :1;
} _CpuRegisters__isset;

class CpuRegisters : public virtual ::apache::thrift::TBase {
 public:

  CpuRegisters(const CpuRegisters&);
  CpuRegisters& operator=(const CpuRegisters&);
  CpuRegisters() : EAX(0), EBX(0), ECX(0), EDX(0), ESI(0), EDI(0), EBP(0), ESP(0), EIP(0), FLAGS(0) {
  }

  virtual ~CpuRegisters() noexcept;
  int32_t EAX;
  int32_t EBX;
  int32_t ECX;
  int32_t EDX;
  int32_t ESI;
  int32_t EDI;
  int32_t EBP;
  int32_t ESP;
  int32_t EIP;
  int16_t FLAGS;

  _CpuRegisters__isset __isset;

  void __set_EAX(const int32_t val);

  void __set_EBX(const int32_t val);

  void __set_ECX(const int32_t val);

  void __set_EDX(const int32_t val);

  void __set_ESI(const int32_t val);

  void __set_EDI(const int32_t val);

  void __set_EBP(const int32_t val);

  void __set_ESP(const int32_t val);

  void __set_EIP(const int32_t val);

  void __set_FLAGS(const int16_t val);

  bool operator == (const CpuRegisters & rhs) const
  {
    if (!(EAX == rhs.EAX))
      return false;
    if (!(EBX == rhs.EBX))
      return false;
    if (!(ECX == rhs.ECX))
      return false;
    if (!(EDX == rhs.EDX))
      return false;
    if (!(ESI == rhs.ESI))
      return false;
    if (!(EDI == rhs.EDI))
      return false;
    if (!(EBP == rhs.EBP))
      return false;
    if (!(ESP == rhs.ESP))
      return false;
    if (!(EIP == rhs.EIP))
      return false;
    if (!(FLAGS == rhs.FLAGS))
      return false;
    return true;
  }
  bool operator != (const CpuRegisters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CpuRegisters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CpuRegisters &a, CpuRegisters &b);

std::ostream& operator<<(std::ostream& out, const CpuRegisters& obj);

typedef struct _SegRegisters__isset {
  _SegRegisters__isset() : CS(false), DS(false), ES(false), FS(false), GS(false), SS(false) {}
  bool CS :1;
  bool DS :1;
  bool ES :1;
  bool FS :1;
  bool GS :1;
  bool SS :1;
} _SegRegisters__isset;

class SegRegisters : public virtual ::apache::thrift::TBase {
 public:

  SegRegisters(const SegRegisters&);
  SegRegisters& operator=(const SegRegisters&);
  SegRegisters() : CS(0), DS(0), ES(0), FS(0), GS(0), SS(0) {
  }

  virtual ~SegRegisters() noexcept;
  int16_t CS;
  int16_t DS;
  int16_t ES;
  int16_t FS;
  int16_t GS;
  int16_t SS;

  _SegRegisters__isset __isset;

  void __set_CS(const int16_t val);

  void __set_DS(const int16_t val);

  void __set_ES(const int16_t val);

  void __set_FS(const int16_t val);

  void __set_GS(const int16_t val);

  void __set_SS(const int16_t val);

  bool operator == (const SegRegisters & rhs) const
  {
    if (!(CS == rhs.CS))
      return false;
    if (!(DS == rhs.DS))
      return false;
    if (!(ES == rhs.ES))
      return false;
    if (!(FS == rhs.FS))
      return false;
    if (!(GS == rhs.GS))
      return false;
    if (!(SS == rhs.SS))
      return false;
    return true;
  }
  bool operator != (const SegRegisters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SegRegisters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SegRegisters &a, SegRegisters &b);

std::ostream& operator<<(std::ostream& out, const SegRegisters& obj);

typedef struct _SegBases__isset {
  _SegBases__isset() : CS_BASE(false), DS_BASE(false), ES_BASE(false), FS_BASE(false), GS_BASE(false), SS_BASE(false) {}
  bool CS_BASE :1;
  bool DS_BASE :1;
  bool ES_BASE :1;
  bool FS_BASE :1;
  bool GS_BASE :1;
  bool SS_BASE :1;
} _SegBases__isset;

class SegBases : public virtual ::apache::thrift::TBase {
 public:

  SegBases(const SegBases&);
  SegBases& operator=(const SegBases&);
  SegBases() : CS_BASE(0), DS_BASE(0), ES_BASE(0), FS_BASE(0), GS_BASE(0), SS_BASE(0) {
  }

  virtual ~SegBases() noexcept;
  int32_t CS_BASE;
  int32_t DS_BASE;
  int32_t ES_BASE;
  int32_t FS_BASE;
  int32_t GS_BASE;
  int32_t SS_BASE;

  _SegBases__isset __isset;

  void __set_CS_BASE(const int32_t val);

  void __set_DS_BASE(const int32_t val);

  void __set_ES_BASE(const int32_t val);

  void __set_FS_BASE(const int32_t val);

  void __set_GS_BASE(const int32_t val);

  void __set_SS_BASE(const int32_t val);

  bool operator == (const SegBases & rhs) const
  {
    if (!(CS_BASE == rhs.CS_BASE))
      return false;
    if (!(DS_BASE == rhs.DS_BASE))
      return false;
    if (!(ES_BASE == rhs.ES_BASE))
      return false;
    if (!(FS_BASE == rhs.FS_BASE))
      return false;
    if (!(GS_BASE == rhs.GS_BASE))
      return false;
    if (!(SS_BASE == rhs.SS_BASE))
      return false;
    return true;
  }
  bool operator != (const SegBases &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SegBases & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SegBases &a, SegBases &b);

std::ostream& operator<<(std::ostream& out, const SegBases& obj);

typedef struct _FpuRegisters__isset {
  _FpuRegisters__isset() : ST0(false), ST1(false), ST2(false), ST3(false), ST4(false), ST5(false), ST6(false), ST7(false) {}
  bool ST0 :1;
  bool ST1 :1;
  bool ST2 :1;
  bool ST3 :1;
  bool ST4 :1;
  bool ST5 :1;
  bool ST6 :1;
  bool ST7 :1;
} _FpuRegisters__isset;

class FpuRegisters : public virtual ::apache::thrift::TBase {
 public:

  FpuRegisters(const FpuRegisters&);
  FpuRegisters& operator=(const FpuRegisters&);
  FpuRegisters() : ST0(0), ST1(0), ST2(0), ST3(0), ST4(0), ST5(0), ST6(0), ST7(0) {
  }

  virtual ~FpuRegisters() noexcept;
  double ST0;
  double ST1;
  double ST2;
  double ST3;
  double ST4;
  double ST5;
  double ST6;
  double ST7;

  _FpuRegisters__isset __isset;

  void __set_ST0(const double val);

  void __set_ST1(const double val);

  void __set_ST2(const double val);

  void __set_ST3(const double val);

  void __set_ST4(const double val);

  void __set_ST5(const double val);

  void __set_ST6(const double val);

  void __set_ST7(const double val);

  bool operator == (const FpuRegisters & rhs) const
  {
    if (!(ST0 == rhs.ST0))
      return false;
    if (!(ST1 == rhs.ST1))
      return false;
    if (!(ST2 == rhs.ST2))
      return false;
    if (!(ST3 == rhs.ST3))
      return false;
    if (!(ST4 == rhs.ST4))
      return false;
    if (!(ST5 == rhs.ST5))
      return false;
    if (!(ST6 == rhs.ST6))
      return false;
    if (!(ST7 == rhs.ST7))
      return false;
    return true;
  }
  bool operator != (const FpuRegisters &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FpuRegisters & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FpuRegisters &a, FpuRegisters &b);

std::ostream& operator<<(std::ostream& out, const FpuRegisters& obj);

typedef struct _DbgBreakpoint__isset {
  _DbgBreakpoint__isset() : type(false), phys_addr(false), enabled(false) {}
  bool type :1;
  bool phys_addr :1;
  bool enabled :1;
} _DbgBreakpoint__isset;

class DbgBreakpoint : public virtual ::apache::thrift::TBase {
 public:

  DbgBreakpoint(const DbgBreakpoint&);
  DbgBreakpoint& operator=(const DbgBreakpoint&);
  DbgBreakpoint() : type((BpType::type)0), phys_addr(0), enabled(0) {
  }

  virtual ~DbgBreakpoint() noexcept;
  /**
   * 
   * @see BpType
   */
  BpType::type type;
  int32_t phys_addr;
  bool enabled;

  _DbgBreakpoint__isset __isset;

  void __set_type(const BpType::type val);

  void __set_phys_addr(const int32_t val);

  void __set_enabled(const bool val);

  bool operator == (const DbgBreakpoint & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(phys_addr == rhs.phys_addr))
      return false;
    if (!(enabled == rhs.enabled))
      return false;
    return true;
  }
  bool operator != (const DbgBreakpoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DbgBreakpoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DbgBreakpoint &a, DbgBreakpoint &b);

std::ostream& operator<<(std::ostream& out, const DbgBreakpoint& obj);



#endif
