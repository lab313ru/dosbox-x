/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "debug_proto_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kCpuRegisterValues[] = {
  CpuRegister::EAX,
  CpuRegister::EBX,
  CpuRegister::ECX,
  CpuRegister::EDX,
  CpuRegister::ESI,
  CpuRegister::EDI,
  CpuRegister::EBP,
  CpuRegister::ESP,
  CpuRegister::EIP,
  CpuRegister::FLAGS
};
const char* _kCpuRegisterNames[] = {
  "EAX",
  "EBX",
  "ECX",
  "EDX",
  "ESI",
  "EDI",
  "EBP",
  "ESP",
  "EIP",
  "FLAGS"
};
const std::map<int, const char*> _CpuRegister_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kCpuRegisterValues, _kCpuRegisterNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const CpuRegister::type& val) {
  std::map<int, const char*>::const_iterator it = _CpuRegister_VALUES_TO_NAMES.find(val);
  if (it != _CpuRegister_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CpuRegister::type& val) {
  std::map<int, const char*>::const_iterator it = _CpuRegister_VALUES_TO_NAMES.find(val);
  if (it != _CpuRegister_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSegRegisterValues[] = {
  SegRegister::CS,
  SegRegister::DS,
  SegRegister::ES,
  SegRegister::FS,
  SegRegister::GS,
  SegRegister::SS
};
const char* _kSegRegisterNames[] = {
  "CS",
  "DS",
  "ES",
  "FS",
  "GS",
  "SS"
};
const std::map<int, const char*> _SegRegister_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kSegRegisterValues, _kSegRegisterNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SegRegister::type& val) {
  std::map<int, const char*>::const_iterator it = _SegRegister_VALUES_TO_NAMES.find(val);
  if (it != _SegRegister_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SegRegister::type& val) {
  std::map<int, const char*>::const_iterator it = _SegRegister_VALUES_TO_NAMES.find(val);
  if (it != _SegRegister_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFpuRegisterValues[] = {
  FpuRegister::ST0,
  FpuRegister::ST1,
  FpuRegister::ST2,
  FpuRegister::ST3,
  FpuRegister::ST4,
  FpuRegister::ST5,
  FpuRegister::ST6,
  FpuRegister::ST7
};
const char* _kFpuRegisterNames[] = {
  "ST0",
  "ST1",
  "ST2",
  "ST3",
  "ST4",
  "ST5",
  "ST6",
  "ST7"
};
const std::map<int, const char*> _FpuRegister_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kFpuRegisterValues, _kFpuRegisterNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const FpuRegister::type& val) {
  std::map<int, const char*>::const_iterator it = _FpuRegister_VALUES_TO_NAMES.find(val);
  if (it != _FpuRegister_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const FpuRegister::type& val) {
  std::map<int, const char*>::const_iterator it = _FpuRegister_VALUES_TO_NAMES.find(val);
  if (it != _FpuRegister_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kBpTypeValues[] = {
  BpType::BP_PC,
  BpType::BP_READ,
  BpType::BP_WRITE
};
const char* _kBpTypeNames[] = {
  "BP_PC",
  "BP_READ",
  "BP_WRITE"
};
const std::map<int, const char*> _BpType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kBpTypeValues, _kBpTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const BpType::type& val) {
  std::map<int, const char*>::const_iterator it = _BpType_VALUES_TO_NAMES.find(val);
  if (it != _BpType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const BpType::type& val) {
  std::map<int, const char*>::const_iterator it = _BpType_VALUES_TO_NAMES.find(val);
  if (it != _BpType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


CpuRegisters::~CpuRegisters() noexcept {
}


void CpuRegisters::__set_EAX(const int32_t val) {
  this->EAX = val;
}

void CpuRegisters::__set_EBX(const int32_t val) {
  this->EBX = val;
}

void CpuRegisters::__set_ECX(const int32_t val) {
  this->ECX = val;
}

void CpuRegisters::__set_EDX(const int32_t val) {
  this->EDX = val;
}

void CpuRegisters::__set_ESI(const int32_t val) {
  this->ESI = val;
}

void CpuRegisters::__set_EDI(const int32_t val) {
  this->EDI = val;
}

void CpuRegisters::__set_EBP(const int32_t val) {
  this->EBP = val;
}

void CpuRegisters::__set_ESP(const int32_t val) {
  this->ESP = val;
}

void CpuRegisters::__set_EIP(const int32_t val) {
  this->EIP = val;
}

void CpuRegisters::__set_FLAGS(const int16_t val) {
  this->FLAGS = val;
}
std::ostream& operator<<(std::ostream& out, const CpuRegisters& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CpuRegisters::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->EAX);
          this->__isset.EAX = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->EBX);
          this->__isset.EBX = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ECX);
          this->__isset.ECX = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->EDX);
          this->__isset.EDX = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ESI);
          this->__isset.ESI = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->EDI);
          this->__isset.EDI = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->EBP);
          this->__isset.EBP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ESP);
          this->__isset.ESP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->EIP);
          this->__isset.EIP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->FLAGS);
          this->__isset.FLAGS = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CpuRegisters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CpuRegisters");

  xfer += oprot->writeFieldBegin("EAX", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->EAX);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("EBX", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->EBX);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ECX", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->ECX);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("EDX", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->EDX);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ESI", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->ESI);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("EDI", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->EDI);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("EBP", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->EBP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ESP", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->ESP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("EIP", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->EIP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("FLAGS", ::apache::thrift::protocol::T_I16, 16);
  xfer += oprot->writeI16(this->FLAGS);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CpuRegisters &a, CpuRegisters &b) {
  using ::std::swap;
  swap(a.EAX, b.EAX);
  swap(a.EBX, b.EBX);
  swap(a.ECX, b.ECX);
  swap(a.EDX, b.EDX);
  swap(a.ESI, b.ESI);
  swap(a.EDI, b.EDI);
  swap(a.EBP, b.EBP);
  swap(a.ESP, b.ESP);
  swap(a.EIP, b.EIP);
  swap(a.FLAGS, b.FLAGS);
  swap(a.__isset, b.__isset);
}

CpuRegisters::CpuRegisters(const CpuRegisters& other0) {
  EAX = other0.EAX;
  EBX = other0.EBX;
  ECX = other0.ECX;
  EDX = other0.EDX;
  ESI = other0.ESI;
  EDI = other0.EDI;
  EBP = other0.EBP;
  ESP = other0.ESP;
  EIP = other0.EIP;
  FLAGS = other0.FLAGS;
  __isset = other0.__isset;
}
CpuRegisters& CpuRegisters::operator=(const CpuRegisters& other1) {
  EAX = other1.EAX;
  EBX = other1.EBX;
  ECX = other1.ECX;
  EDX = other1.EDX;
  ESI = other1.ESI;
  EDI = other1.EDI;
  EBP = other1.EBP;
  ESP = other1.ESP;
  EIP = other1.EIP;
  FLAGS = other1.FLAGS;
  __isset = other1.__isset;
  return *this;
}
void CpuRegisters::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CpuRegisters(";
  out << "EAX=" << to_string(EAX);
  out << ", " << "EBX=" << to_string(EBX);
  out << ", " << "ECX=" << to_string(ECX);
  out << ", " << "EDX=" << to_string(EDX);
  out << ", " << "ESI=" << to_string(ESI);
  out << ", " << "EDI=" << to_string(EDI);
  out << ", " << "EBP=" << to_string(EBP);
  out << ", " << "ESP=" << to_string(ESP);
  out << ", " << "EIP=" << to_string(EIP);
  out << ", " << "FLAGS=" << to_string(FLAGS);
  out << ")";
}


SegRegisters::~SegRegisters() noexcept {
}


void SegRegisters::__set_CS(const int16_t val) {
  this->CS = val;
}

void SegRegisters::__set_DS(const int16_t val) {
  this->DS = val;
}

void SegRegisters::__set_ES(const int16_t val) {
  this->ES = val;
}

void SegRegisters::__set_FS(const int16_t val) {
  this->FS = val;
}

void SegRegisters::__set_GS(const int16_t val) {
  this->GS = val;
}

void SegRegisters::__set_SS(const int16_t val) {
  this->SS = val;
}
std::ostream& operator<<(std::ostream& out, const SegRegisters& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SegRegisters::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->CS);
          this->__isset.CS = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->DS);
          this->__isset.DS = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->ES);
          this->__isset.ES = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->FS);
          this->__isset.FS = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->GS);
          this->__isset.GS = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->SS);
          this->__isset.SS = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SegRegisters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SegRegisters");

  xfer += oprot->writeFieldBegin("CS", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->CS);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("DS", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->DS);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ES", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->ES);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("FS", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->FS);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("GS", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->GS);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("SS", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->SS);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SegRegisters &a, SegRegisters &b) {
  using ::std::swap;
  swap(a.CS, b.CS);
  swap(a.DS, b.DS);
  swap(a.ES, b.ES);
  swap(a.FS, b.FS);
  swap(a.GS, b.GS);
  swap(a.SS, b.SS);
  swap(a.__isset, b.__isset);
}

SegRegisters::SegRegisters(const SegRegisters& other2) {
  CS = other2.CS;
  DS = other2.DS;
  ES = other2.ES;
  FS = other2.FS;
  GS = other2.GS;
  SS = other2.SS;
  __isset = other2.__isset;
}
SegRegisters& SegRegisters::operator=(const SegRegisters& other3) {
  CS = other3.CS;
  DS = other3.DS;
  ES = other3.ES;
  FS = other3.FS;
  GS = other3.GS;
  SS = other3.SS;
  __isset = other3.__isset;
  return *this;
}
void SegRegisters::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SegRegisters(";
  out << "CS=" << to_string(CS);
  out << ", " << "DS=" << to_string(DS);
  out << ", " << "ES=" << to_string(ES);
  out << ", " << "FS=" << to_string(FS);
  out << ", " << "GS=" << to_string(GS);
  out << ", " << "SS=" << to_string(SS);
  out << ")";
}


SegBases::~SegBases() noexcept {
}


void SegBases::__set_CS_BASE(const int32_t val) {
  this->CS_BASE = val;
}

void SegBases::__set_DS_BASE(const int32_t val) {
  this->DS_BASE = val;
}

void SegBases::__set_ES_BASE(const int32_t val) {
  this->ES_BASE = val;
}

void SegBases::__set_FS_BASE(const int32_t val) {
  this->FS_BASE = val;
}

void SegBases::__set_GS_BASE(const int32_t val) {
  this->GS_BASE = val;
}

void SegBases::__set_SS_BASE(const int32_t val) {
  this->SS_BASE = val;
}
std::ostream& operator<<(std::ostream& out, const SegBases& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SegBases::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->CS_BASE);
          this->__isset.CS_BASE = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->DS_BASE);
          this->__isset.DS_BASE = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ES_BASE);
          this->__isset.ES_BASE = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->FS_BASE);
          this->__isset.FS_BASE = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->GS_BASE);
          this->__isset.GS_BASE = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->SS_BASE);
          this->__isset.SS_BASE = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SegBases::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SegBases");

  xfer += oprot->writeFieldBegin("CS_BASE", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->CS_BASE);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("DS_BASE", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->DS_BASE);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ES_BASE", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->ES_BASE);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("FS_BASE", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->FS_BASE);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("GS_BASE", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->GS_BASE);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("SS_BASE", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->SS_BASE);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SegBases &a, SegBases &b) {
  using ::std::swap;
  swap(a.CS_BASE, b.CS_BASE);
  swap(a.DS_BASE, b.DS_BASE);
  swap(a.ES_BASE, b.ES_BASE);
  swap(a.FS_BASE, b.FS_BASE);
  swap(a.GS_BASE, b.GS_BASE);
  swap(a.SS_BASE, b.SS_BASE);
  swap(a.__isset, b.__isset);
}

SegBases::SegBases(const SegBases& other4) {
  CS_BASE = other4.CS_BASE;
  DS_BASE = other4.DS_BASE;
  ES_BASE = other4.ES_BASE;
  FS_BASE = other4.FS_BASE;
  GS_BASE = other4.GS_BASE;
  SS_BASE = other4.SS_BASE;
  __isset = other4.__isset;
}
SegBases& SegBases::operator=(const SegBases& other5) {
  CS_BASE = other5.CS_BASE;
  DS_BASE = other5.DS_BASE;
  ES_BASE = other5.ES_BASE;
  FS_BASE = other5.FS_BASE;
  GS_BASE = other5.GS_BASE;
  SS_BASE = other5.SS_BASE;
  __isset = other5.__isset;
  return *this;
}
void SegBases::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SegBases(";
  out << "CS_BASE=" << to_string(CS_BASE);
  out << ", " << "DS_BASE=" << to_string(DS_BASE);
  out << ", " << "ES_BASE=" << to_string(ES_BASE);
  out << ", " << "FS_BASE=" << to_string(FS_BASE);
  out << ", " << "GS_BASE=" << to_string(GS_BASE);
  out << ", " << "SS_BASE=" << to_string(SS_BASE);
  out << ")";
}


FpuRegisters::~FpuRegisters() noexcept {
}


void FpuRegisters::__set_ST0(const double val) {
  this->ST0 = val;
}

void FpuRegisters::__set_ST1(const double val) {
  this->ST1 = val;
}

void FpuRegisters::__set_ST2(const double val) {
  this->ST2 = val;
}

void FpuRegisters::__set_ST3(const double val) {
  this->ST3 = val;
}

void FpuRegisters::__set_ST4(const double val) {
  this->ST4 = val;
}

void FpuRegisters::__set_ST5(const double val) {
  this->ST5 = val;
}

void FpuRegisters::__set_ST6(const double val) {
  this->ST6 = val;
}

void FpuRegisters::__set_ST7(const double val) {
  this->ST7 = val;
}
std::ostream& operator<<(std::ostream& out, const FpuRegisters& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FpuRegisters::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ST0);
          this->__isset.ST0 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ST1);
          this->__isset.ST1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ST2);
          this->__isset.ST2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ST3);
          this->__isset.ST3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ST4);
          this->__isset.ST4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ST5);
          this->__isset.ST5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ST6);
          this->__isset.ST6 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ST7);
          this->__isset.ST7 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FpuRegisters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FpuRegisters");

  xfer += oprot->writeFieldBegin("ST0", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->ST0);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ST1", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->ST1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ST2", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->ST2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ST3", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->ST3);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ST4", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->ST4);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ST5", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->ST5);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ST6", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->ST6);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ST7", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->ST7);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FpuRegisters &a, FpuRegisters &b) {
  using ::std::swap;
  swap(a.ST0, b.ST0);
  swap(a.ST1, b.ST1);
  swap(a.ST2, b.ST2);
  swap(a.ST3, b.ST3);
  swap(a.ST4, b.ST4);
  swap(a.ST5, b.ST5);
  swap(a.ST6, b.ST6);
  swap(a.ST7, b.ST7);
  swap(a.__isset, b.__isset);
}

FpuRegisters::FpuRegisters(const FpuRegisters& other6) {
  ST0 = other6.ST0;
  ST1 = other6.ST1;
  ST2 = other6.ST2;
  ST3 = other6.ST3;
  ST4 = other6.ST4;
  ST5 = other6.ST5;
  ST6 = other6.ST6;
  ST7 = other6.ST7;
  __isset = other6.__isset;
}
FpuRegisters& FpuRegisters::operator=(const FpuRegisters& other7) {
  ST0 = other7.ST0;
  ST1 = other7.ST1;
  ST2 = other7.ST2;
  ST3 = other7.ST3;
  ST4 = other7.ST4;
  ST5 = other7.ST5;
  ST6 = other7.ST6;
  ST7 = other7.ST7;
  __isset = other7.__isset;
  return *this;
}
void FpuRegisters::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FpuRegisters(";
  out << "ST0=" << to_string(ST0);
  out << ", " << "ST1=" << to_string(ST1);
  out << ", " << "ST2=" << to_string(ST2);
  out << ", " << "ST3=" << to_string(ST3);
  out << ", " << "ST4=" << to_string(ST4);
  out << ", " << "ST5=" << to_string(ST5);
  out << ", " << "ST6=" << to_string(ST6);
  out << ", " << "ST7=" << to_string(ST7);
  out << ")";
}


DbgBreakpoint::~DbgBreakpoint() noexcept {
}


void DbgBreakpoint::__set_type(const BpType::type val) {
  this->type = val;
}

void DbgBreakpoint::__set_phys_addr(const int32_t val) {
  this->phys_addr = val;
}

void DbgBreakpoint::__set_enabled(const bool val) {
  this->enabled = val;
}
std::ostream& operator<<(std::ostream& out, const DbgBreakpoint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DbgBreakpoint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->type = (BpType::type)ecast8;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->phys_addr);
          this->__isset.phys_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enabled);
          this->__isset.enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DbgBreakpoint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DbgBreakpoint");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("phys_addr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->phys_addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enabled", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DbgBreakpoint &a, DbgBreakpoint &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.phys_addr, b.phys_addr);
  swap(a.enabled, b.enabled);
  swap(a.__isset, b.__isset);
}

DbgBreakpoint::DbgBreakpoint(const DbgBreakpoint& other9) {
  type = other9.type;
  phys_addr = other9.phys_addr;
  enabled = other9.enabled;
  __isset = other9.__isset;
}
DbgBreakpoint& DbgBreakpoint::operator=(const DbgBreakpoint& other10) {
  type = other10.type;
  phys_addr = other10.phys_addr;
  enabled = other10.enabled;
  __isset = other10.__isset;
  return *this;
}
void DbgBreakpoint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DbgBreakpoint(";
  out << "type=" << to_string(type);
  out << ", " << "phys_addr=" << to_string(phys_addr);
  out << ", " << "enabled=" << to_string(enabled);
  out << ")";
}


